import re
import pandas as pd
from pathlib import Path
from src.utils.util import clean_groups
from src.python_objects.base import Base
from collections import defaultdict
import os
import subprocess


class MatlabProgramRunner(Base):
    def __init__(self, conversion_weights_pairs={}):
        super().__init__(conversion_weights_pairs={})

    def write_matlab_params(self) -> None:
        """
        Extracts the max number of groups for each year pair from the matrices
        directory.

        Writes the parameters for the MATLAB optimization to a file
        to be used by the matlab scrip to a tmp data folder
        """
        matrices_dir = self.data_path / "matrices"
        files = matrices_dir.glob("*.csv")

        result = self.extract_max_groups(files)

        start_years = []
        end_years = []
        max_groups = []

        for (start, end), max_group in sorted(result.items()):
            start_years.append(str(start))
            end_years.append(str(end))
            max_groups.append(
                str(max_group)
            )  # We'll convert these back to integers in the output

        output_dir = self.data_path / "temp"
        os.makedirs(output_dir, exist_ok=True)

        output_file = output_dir / "matlab_script_params.txt"
        with open(output_file, "w") as f:
            f.write("# Generated by generator_params.py\n\n")
            # Write each parameter on a new line
            f.write('START_YEARS="' + " ".join(start_years) + '"\n')
            f.write('END_YEARS="' + " ".join(end_years) + '"\n')
            f.write('MAX_GROUPS="' + " ".join(max_groups) + '"\n')

        self.logger.info(f"Parameters written to {output_file}")

    def extract_max_groups(self, filenames: list[Path]) -> dict:
        """
        Extracts the max number of groups for each year pair from the matrices
        directory.
        """
        # Dictionary to store max group number for each year pair
        max_groups = defaultdict(int)

        # Regex pattern to extract years and group numbers
        pattern = r"start\.(\d+)\.end\.(\d+)\.group\.(\d+)\.csv"

        for file in filenames:
            match = re.search(pattern, file.name)
            if match:
                start_year = int(match.group(1))
                end_year = int(match.group(2))
                group_num = int(match.group(3))

                # Update max group if larger
                year_pair = (start_year, end_year)
                max_groups[year_pair] = max(max_groups[year_pair], group_num)

        return max_groups

    def run_matlab_optimization(self) -> None:
        """
        Check if matlab is installed and properly added to the system's PATH
        environment variable.

        Runs the MATLAB optimization code to generate weights
        """
        script_dir = self.root_dir / "src" / "scripts"
        bash_script = script_dir / "run_matlab_optimization.sh"

        try:
            subprocess.run(
                [
                    "matlab",
                    "-nodisplay",
                    "-batch",
                    "disp('MATLAB loaded successfully')",
                ],
                check=True,
            )
        except FileNotFoundError:
            raise ValueError(
                "MATLAB not found. Please install MATLAB and ensure it's in your PATH. "
                "You can test this by running 'matlab -nodisplay -batch \"disp('test')\"' "
                "from the command line."
            )
        except subprocess.CalledProcessError as e:
            raise ValueError(
                f"MATLAB found but failed to run properly. Error: {e.stderr if e.stderr else e}"
            )

        try:
            os.chmod(bash_script, 0o755)
        except FileNotFoundError:
            raise ValueError(f"Bash script not found: {bash_script}")

        try:
            result = subprocess.run(
                ["bash", bash_script], check=True, capture_output=True, text=True
            )

            self.logger.info("MATLAB optimization completed successfully")
            self.logger.info(f"Output: {result.stdout}")
            if result.stderr:
                self.logger.error("Errors:", result.stderr)

        except subprocess.CalledProcessError as e:
            error_msg = f"MATLAB optimization failed with return code {e.returncode}"
            if e.stderr:
                error_msg += f"\nError output: {e.stderr}"
            if e.stdout:
                error_msg += f"\nStandard output: {e.stdout}"
            raise ValueError(error_msg)
